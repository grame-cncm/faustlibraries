// #############################################################################
// ##########  Antialiased nonlinearities (aanl.lib) ###########################
// #############################################################################
//
// This library provides aliasing-suppressed nonlinearities through first-order 
// and second-order approximations of continuous-time signals, functions,
// and convolution based on antiderivatives.
//
// The library contains trigonometric functions as well as other nonlinear 
// functions such as bounded and unbounded saturators.
//
// Due to their limited domains or ranges, some of these functions are not 
// suitable for audio nonlinear processing or waveshaping, although
// they have been included for completeness. Some other functions,
// for example, tan() and tanh(), are only available with first-order
// antialiasing due to the complexity of the antiderivative of the 
// x*f(x) term, particularly because of the necessity of the dilogarithm 
// function, which requires special implementation.
//
// Note that the antialiasing functions introduce a delay in the path,
// respectively half and one-sample delay for first and second-order functions.
//
// Also note that due to division by differences, it is vital to use
// double-precision or more to reduce errors.
//
// The environment identifier for this library is "aa". After importing
// the standard libraries in Faust, the functions below can be called as:
//
//    "aa.function_name".
//
// Reference:
// https://www.dafx.de/paper-archive/2016/dafxpapers/20-DAFx-16_paper_41-PN.pdf.
//
// #############################################################################

declare name "Antialiased nonlinearities";
declare version "0.1";

ba = library("basics.lib");
ma = library("maths.lib");


// =============================================================================
// ========== Auxiliary Functions ==============================================
// =============================================================================

// ---------- Constants --------------------------------------------------------
//
EPS = ma.EPSILON;
MAX = ma.INFINITY;
MIN = ma.MIN;
// -----------------------------------------------------------------------------

// ---------- clip; ------------------------------------------------------------
//
clip(l, h, x) = max(l, min(h, x));
// -----------------------------------------------------------------------------

// ---------- Real-valued sqrt() -----------------------------------------------
//
Rsqrt(x) = sqrt(max(0.0, x));
// -----------------------------------------------------------------------------

// ---------- Real-valued log() ------------------------------------------------
//
Rlog(x) = log(max(EPS, x));
// -----------------------------------------------------------------------------

// ---------- Real-valued tan() ------------------------------------------------
//
Rtan(x) = tan(clip(-MAX, MAX, x));
// -----------------------------------------------------------------------------

// ---------- Real-valued acos() -----------------------------------------------
//
Racos(x) = acos(clip(-1.0, 1.0, x));
// -----------------------------------------------------------------------------

// ---------- Real-valued asin() -----------------------------------------------
//
Rasin(x) = asin(clip(-1.0, 1.0, x));
// -----------------------------------------------------------------------------

// ---------- Real-valued acosh() ----------------------------------------------
//
Racosh(x) = ma.acosh(clip(1.0, MAX, x));
// -----------------------------------------------------------------------------

// ---------- Real-valued cosh() -----------------------------------------------
//
Rcosh(x) = min(MAX, ma.cosh(x));
// -----------------------------------------------------------------------------

// ---------- Real-valued sinh() -----------------------------------------------
//
Rsinh(x) = clip(-MAX, MAX, ma.sinh(x));
// -----------------------------------------------------------------------------

// ---------- Real-valued atanh() ----------------------------------------------
//
Ratanh(x) = ma.atanh(clip(-1.0 + EPS, 1.0 - EPS, x));
// -----------------------------------------------------------------------------

// ---------- Generalised first-order ADAA function ----------------------------
//
declare ADAA1 author "Dario Sanfilippo";
declare ADAA1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare ADAA1 license "LGPL v3.0 license";
ADAA1(f, F1, x) = D1q
      with {
           D1q = ba.if(abs(x - x') <= EPS, ill_D1q, safe_D1q)
               with {
                   ill_D1q = f(x_m);
                   safe_D1q = (F1(x) - F1(x')) / (x - x');
                   x_m = .5 * (x + x');
               };
      };
// -----------------------------------------------------------------------------

// ---------- Generalised second-order ADAA function ---------------------------
//
declare ADAA2 author "Dario Sanfilippo";
declare ADAA2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare ADAA2 license "LGPL v3.0 license";
ADAA2(f, F1, F2, x) = T1 + T2
      with {
           T1 = ba.if((x - x') ^ 2.0 <= EPS, ill_T1, safe_T1)
               with {
                   ill_T1 = .5 * f((x + 2.0 * x') / 3.0);
                   safe_T1 = (x * (F1(x) - F1(x')) - (F2(x) - F2(x'))) /
                       ((x - x') ^ 2.0);
               };
           T2 = ba.if((x' - x'') ^ 2.0 <= EPS, ill_T2, safe_T2)
               with {
                   ill_T2 = .5 * f((x'' + 2.0 * x') / 3.0);
                   safe_T2 = (x'' * (F1(x'') - F1(x')) - (F2(x'') - F2(x'))) /
                       ((x'' - x') ^ 2.0);
               };
      };
// -----------------------------------------------------------------------------



// =============================================================================
// ========== Main functions ===================================================
// =============================================================================

// -----------------------------------------------------------------------------
// ---------- Saturators -------------------------------------------------------
// -----------------------------------------------------------------------------

// ---------- (aa.)hardclip; ---------------------------------------------------
//
// First-order ADAA hard-clip.
//
// #### Usage
// ```
// _ : aa.hardclip : _;
// ```
declare hardclip author "Dario Sanfilippo";
declare hardclip copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare hardclip license "LGPL v3.0 license";
hardclip(x) = ADAA1(f, F1, x)
    with {
        f(x_f) = clip(-1.0, 1.0, x_f);
        F1(x_F1) = ba.if(  (x_F1 <= 1.0) & (x_F1 >= -1.0), 
                           .5 * x_F1 ^ 2.0, 
                           x_F1 * ma.signum(x_F1) - .5);
    };
// -----------------------------------------------------------------------------

// ---------- (aa.)hardclip2; --------------------------------------------------
//
// Second-order ADAA hard-clip.
//
// #### Usage
// ```
// _ : aa.hardclip2 : _;
// ```
declare hardclip2 author "Dario Sanfilippo";
declare hardclip2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare hardclip2 license "LGPL v3.0 license";
hardclip2(x) = ADAA2(f, F1, F2, x) 
    with {
        f(x_f) = clip(-1.0, 1.0, x_f);
        F1(x_F1) = ba.if(  (x_F1 <= 1.0) & (x_F1 >= -1.0), 
                           .5 * x_F1 ^ 2.0, 
                           x_F1 * ma.signum(x_F1) - .5);
        F2(x_F2) = ba.if(  (x_F2 <= 1.0) & (x_F2 >= -1.0), 
                           (1.0 / 3.0) * x_F2 ^ 3.0, 
                           ((.5 * x_F2 ^ 2.0) - 1.0 / 6.0) * ma.signum(x_F2));
    };
// -----------------------------------------------------------------------------

// ---------- (aa.)parabolic; --------------------------------------------------
//
// First-order ADAA parabolic saturator.
//
// #### Usage
// ```
// _ : aa.parabolic : _;
// ```
declare parabolic author "Dario Sanfilippo";
declare parabolic copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare parabolic license "LGPL v3.0 license";
parabolic(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = ba.if( abs(x_f) <= 2.0, 
                           x_f * (1.0 - abs(x_f) / 4.0), 
                           ma.signum(x_f));
           F1(x_F1) = ba.if(   abs(x_F1) <= 2.0, 
                               (-1.0 / 12.0) * x_F1 ^ 2.0 * 
                                   (x_F1 * ma.signum(x_F1) - 6.0),
                               abs(x_F1));
      };
// -----------------------------------------------------------------------------

// ---------- (aa.)parabolic2; -------------------------------------------------
//
// Second-order ADAA parabolic saturator.
//
// #### Usage
// ```
// _ : aa.parabolic : _;
// ```
declare parabolic2 author "Dario Sanfilippo";
declare parabolic2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare parabolic2 license "LGPL v3.0 license";
parabolic2(x) = ADAA2(f, F1, F2, x) 
      with {
           f(x_f) = ba.if( abs(x_f) <= 2.0,
                           x_f * (1.0 - abs(x_f) / 4.0),
                           ma.signum(x_f));
           F1(x_F1) = ba.if(   abs(x_F1) <= 2.0,
                               (-1.0 / 12.0) * x_F1 ^ 2.0 * 
                                   (x_F1 * ma.signum(x_F1) - 6.0),
                               abs(x_F1));
           F2(x_F2) = ba.if(   abs(x_F2) <= 2.0,
                               (1.0 / 48.0) * x_F2 ^ 3.0 * 
                                   (16.0 - 3.0 * x_F2 * ma.signum(x_F2)),
                               .5 * x_F2 ^ 2.0 * ma.signum(x_F2));
      };
// -----------------------------------------------------------------------------

// ---------- (aa.)sinarctan; --------------------------------------------------
//
// First-order ADAA sin(atan()) saturator.
//
// #### Usage
// ```
// _ : aa.sinatan : _;
// ```
declare sinarctan author "Dario Sanfilippo";
declare sinarctan copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinarctan license "LGPL v3.0 license";
sinarctan(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = x_f / sqrt(1.0 + x_f ^ 2.0);
           F1(x_F1) = sqrt(x_F1 ^ 2.0 + 1.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
      };
// -----------------------------------------------------------------------------

// ---------- (aa.)sinarctan2; -------------------------------------------------
//
// Second-order ADAA sin(atan()) saturator.
//
// #### Usage
// ```
// _ : aa.sinarctan2 : _;
// ```
declare sinarctan2 author "Dario Sanfilippo";
declare sinarctan2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinarctan2 license "LGPL v3.0 license";
sinarctan2(x) = ADAA2(f, F1, F2, x) 
      with {
           f(x_f) = x_f / sqrt(1.0 + x_f ^ 2.0);
           F1(x_F1) = sqrt(x_F1 ^ 2.0 + 1.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .5 * x_F2 * sqrt(x_F2 ^ 2.0 + 1.0) - .5 * ma.asinh(x_F2);
      };
// -----------------------------------------------------------------------------

// ---------- (aa.)tanh; -------------------------------------------------------
//
// First-order ADAA tanh() saturator.
//
// #### Usage
// ```
// _ : aa.tanh : _;
// ```
declare tanh author "Dario Sanfilippo";
declare tanh copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare tanh license "LGPL v3.0 license";
tanh(x) = ADAA1(f, F1, x) 
      with {
           f(x_f) = ma.tanh(x_f);
           F1(x_F1) = log(Rcosh(x_F1));
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)arctan; -----------------------------------------------------
//
// First-order ADAA atan().
//
// #### Usage
// ```
// _ : ad.arctan : _;
// ```
declare arctan author "Dario Sanfilippo";
declare arctan copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arctan license "LGPL v3.0 license";
arctan(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = atan(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - .5 * log(x_F1 ^ 2.0 + 1.0);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)arctan2; ----------------------------------------------------
//
// Second-order ADAA atan().
//
// #### Usage
// ```
// _ : ad.arctan2 : _;
// ```
declare arctan2 author "Dario Sanfilippo";
declare arctan2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arctan2 license "LGPL v3.0 license";
arctan2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = atan(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - .5 * log(x_F1 ^ 2.0 + 1.0);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) - x_F2 / 2.0 + .5 * f(x_F2);
      };
// -----------------------------------------------------------------------------

// ---------- (aa.)asinh; ------------------------------------------------------
//
// First-order ADAA asinh() saturator (unbounded).
//
// #### Usage
// ```
// _ : aa.asinh : _;
// ```
declare asinh author "Dario Sanfilippo";
declare asinh copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare asinh license "LGPL v3.0 license";
asinh(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = ma.asinh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - sqrt(1.0 + x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };

      };
// -----------------------------------------------------------------------------

// ---------- (aa.)asinh2; -----------------------------------------------------
//
// Second-order ADAA asinh() saturator (unbounded).
//
// #### Usage
// ```
// _ : aa.asinh2 : _;
// ```
declare asinh2 author "Dario Sanfilippo";
declare asinh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare asinh2 license "LGPL v3.0 license";
asinh2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = ma.asinh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - sqrt(1.0 + x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (2.0 * x_F2 ^ 2.0 * f(x_F2) + f(x_F2) - 
               sqrt(x_F2 ^ 2.0 + 1.0) * x_F2);

      };
// -----------------------------------------------------------------------------



// -----------------------------------------------------------------------------
// ---------- Trigonometry -----------------------------------------------------
// -----------------------------------------------------------------------------

// ---------- (aa.)cosine; -----------------------------------------------------
//
// First-order ADAA cos().
//
// #### Usage
// ```
// _ : aa.cosine : _;
// ```
declare cosine author "Dario Sanfilippo";
declare cosine copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosine license "LGPL v3.0 license";
cosine(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = cos(x_f);
           F1(x_F1) = sin(x_F1);
      };
// -----------------------------------------------------------------------------

// ---------- (aa.)cosine2; ----------------------------------------------------
//
// Second-order ADAA cos().
//
// #### Usage
// ```
// _ : aa.cosine2 : _;
// ```
declare cosine2 author "Dario Sanfilippo";
declare cosine2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosine2 license "LGPL v3.0 license";
cosine2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = cos(x_f);
           F1(x_F1) = sin(x_F1);
           F2(x_F2) = x_F2 * sin(x_F2) + cos(x_F2);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)arccos; -----------------------------------------------------
//
// First-order ADAA acos().
//
// #### Usage
// ```
// _ : ad.arccos : _;
// ```
declare arccos author "Dario Sanfilippo";
declare arccos copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arccos license "LGPL v3.0 license";
arccos(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = Racos(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)arccos2; ----------------------------------------------------
//
// Second-order ADAA acos().
//
// Note that this function is not accurate for low-amplitude input
// signals. In that case, the first-order ADAA arccos() can be used.
//
// #### Usage
// ```
// _ : ad.arccos2 : _;
// ```
declare arccos2 author "Dario Sanfilippo";
declare arccos2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arccos2 license "LGPL v3.0 license";
arccos2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = Racos(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (2.0 * x_F2 ^ 2.0 * f(x_F2) + Rasin(x_F2) -
               Rsqrt(1.0 - x_F2 ^ 2.0));
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)cosh; -------------------------------------------------------
//
// First-order ADAA cosh(). (Not effective on this nonlinearity.)
//
// #### Usage
// ```
// _ : ad.cosh : _;
// ```
declare cosh author "Dario Sanfilippo";
declare cosh copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosh license "LGPL v3.0 license";
cosh(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = Rcosh(x_f);
           F1(x_F1) = Rsinh(x_F1);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)cosh2; ------------------------------------------------------
//
// Second-order ADAA cosh(). (Not effective on this nonlinearity.)
//
// #### Usage
// ```
// _ : ad.cosh2 : _;
// ```
declare cosh2 author "Dario Sanfilippo";
declare cosh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosh2 license "LGPL v3.0 license";
cosh2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = Rcosh(x_f);
           F1(x_F1) = Rsinh(x_F1);
           F2(x_F2) = x_F2 * F1(x_F2) - f(x_F2) + 1.0;
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)acosh; ------------------------------------------------------
//
// First-order ADAA acosh(). 
//
// #### Usage
// ```
// _ : ad.acosh : _;
// ```
declare acosh author "Dario Sanfilippo";
declare acosh copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare acosh license "LGPL v3.0 license";
acosh(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = Racosh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(x_F1 - 1.0) * Rsqrt(x_F1 + 1.0);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)acosh2; -----------------------------------------------------
//
// Second-order ADAA acosh().
//
// Note that this function is not accurate for low-amplitude input
// signals. In that case, the first-order ADAA acosh() can be used.
//
// #### Usage
// ```
// _ : ad.acosh2 : _;
// ```
declare acosh2 author "Dario Sanfilippo";
declare acosh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare acosh2 license "LGPL v3.0 license";
acosh2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = Racosh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(x_F1 - 1.0) * Rsqrt(x_F1 + 1.0);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) - .25 * 
               Rsqrt(x_F2 - 1.0) * Rsqrt(x_F2 + 1.0) * x_F2 -
                   .25 * Rlog(x_F2 + Rsqrt(x_F2 - 1.0) * Rsqrt(x_F2 + 1.0));
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)sine; -------------------------------------------------------
//
// First-order ADAA sin().
//
// #### Usage
// ```
// _ : ad.sine : _;
// ```
declare sine author "Dario Sanfilippo";
declare sine copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sine license "LGPL v3.0 license";
sine(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = sin(x_f);
           F1(x_F1) = -1.0 * cos(x_F1);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)sine2; ------------------------------------------------------
//
// Second-order ADAA sin().
//
// #### Usage
// ```
// _ : ad.sine2 : _;
// ```
declare sine2 author "Dario Sanfilippo";
declare sine2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sine2 license "LGPL v3.0 license";
sine2(x) = ADAA2(f, F1, F2, x) 
      with {
           f(x_f) = sin(x_f);
           F1(x_F1) = 1.0 - cos(x_F1);
           F2(x_F2) = sin(x_F2) - x_F2 * cos(x_F2);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)arcsin; -----------------------------------------------------
//
// First-order ADAA asin().
//
// #### Usage
// ```
// _ : ad.arcsin : _;
// ```
declare arcsin author "Dario Sanfilippo";
declare arcsin copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arcsin license "LGPL v3.0 license";
arcsin(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = Rasin(x_f);
           F1(x_F1) = x_F1 * f(x_F1) + Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)arcsin2; ----------------------------------------------------
//
// Second-order ADAA asin().
//
// #### Usage
// ```
// _ : ad.arcsin2 : _;
// ```
declare arcsin2 author "Dario Sanfilippo";
declare arcsin2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arcsin2 license "LGPL v3.0 license";
arcsin2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = Rasin(x_f);
           F1(x_F1) = x_F1 * f(x_F1) + Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (Rsqrt(1.0 - x_F2 ^ 2.0) * x_F2 + 
               (2.0 * x_F2 ^ 2.0 - 1.0) * f(x_F2));
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)sinh; -------------------------------------------------------
//
// First-order ADAA sinh(). (Not effective on this nonlinearity.)
//
// #### Usage
// ```
// _ : ad.sinh : _;
// ```
declare sinh author "Dario Sanfilippo";
declare sinh copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinh license "LGPL v3.0 license";
sinh(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = Rsinh(x_f);
           F1(x_F1) = Rcosh(x_F1) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)sinh2; -------------------------------------------------------
//
// Second-order ADAA sinh(). (Not effective on this nonlinearity.)
//
// #### Usage
// ```
// _ : ad.sinh2 : _;
// ```
declare sinh2 author "Dario Sanfilippo";
declare sinh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinh2 license "LGPL v3.0 license";
sinh2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = Rsinh(x_f);
           F1(x_F1) = Rcosh(x_F1) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = x_F2 * F1(x_F2) - f(x_F2);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)tangent; ----------------------------------------------------
//
// First-order ADAA tan().
//
// #### Usage
// ```
// _ : ad.tangent : _;
// ```
declare tangent author "Dario Sanfilippo";
declare tangent copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare tangent license "LGPL v3.0 license";
tangent(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = Rtan(x_f);
           F1(x_F1) = -1.0 * Rlog(cos(x_F1));
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)atanh; ------------------------------------------------------
//
// First-order ADAA atanh(). 
//
// #### Usage
// ```
// _ : ad.atanh : _;
// ```
declare atanh author "Dario Sanfilippo";
declare atanh copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare atanh license "LGPL v3.0 license";
atanh(x) = ADAA1(f, F1, x)
      with {
           f(x_f) = Ratanh(x_f);
           F1(x_F1) = .5 * Rlog(1.0 - x_F1 ^ 2.0) + x_F1 * f(x_F1);
      };
// -----------------------------------------------------------------------------

// ---------- (ad.)atanh2; -----------------------------------------------------
//
// Second-order ADAA atanh().
//
// Note that this function is working only for low-amplitude inputs. For
// other cases, the first-order ADAA can be used.
//
// #### Usage
// ```
// _ : ad.atanh2 : _;
// ```
declare atanh2 author "Dario Sanfilippo";
declare atanh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare atanh2 license "LGPL v3.0 license";
atanh2(x) = ADAA2(f, F1, F2, x)
      with {
           f(x_f) = Ratanh(x_f);
           F1(x_F1) = .5 * Rlog(1.0 - x_F1 ^ 2.0) + x_F1 * f(x_F1);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) + x_F2 / 2.0 + .25 * 
               Rlog(1.0 - x_F2) - .25 * Rlog(1.0 + x_F2);
      };
// -----------------------------------------------------------------------------
