//#################################### reducemaps.lib ########################################
// A library to handle reduce/map kind of operation in Faust. Its official prefix is `rm`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/reducemaps.lib>
//##############################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2010-2011 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation; either version 2.1 of the 
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA. 

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");

declare name "Reduce Library";
declare author "Yann Orlarey (orlarey at grame.fr)";
declare copyright "Grame";
declare version "0.1";
declare license "LGPL with exception"; 

//---------------------------------------------------------------
// Provides various operations on block of samples
// using a high order 'reduce(op, n)' fold-like function :
//
//   sumn(n) : the sum  of a block of n input samples
//   maxn(n) : the max  of a block of n input samples
//   minn(n) : the min  of a block of n input samples
//   mean(n) : the mean of a block of n input samples
//   RMS(n)  : the RMS  of a block of n input samples
//---------------------------------------------------------------


//--------------------`(rm.)reduce`------------------------------
// Fold-like high order function. Apply a binary operation `op`
// on a block of consecutive samples of a signal `x`. 
// For example: `reduce(max,128)` will compute the maximun of each
// block of 128 samples. Please note that the resulting
// value, while produced continuously, will be constant for 
// the duration of a block. A new value is only produced 
// at the end of a block. Note also that blocks should be of at
// least one sample (n>0). 
//
// #### Usage
//
// ```
// reduce(op, n, x)
// ```
//-----------------------------------------------------------------------------

reduce(op, n, x) = compute ~ (_,_,_) : (!,!,_)
    with {
        compute(acc, count, val) =
            ba.if(count<n, op(acc,x), x), // new acc
            ba.if(count<n, count+1, 1),   // new count
            ba.if(count<n, val, acc);     // new val
    };


//--------------------`(rm.)reducemap`---------------------------
// Like `reduce` but a `foo` function is applied to the result. From
// a mathematical point of view:
// `reducemap(op,foo,n)` is equivalent to `reduce(op,n):foo`
// but more efficient.
//
// #### Usage
//
// ```
// reducemap(op, foo, n, x)
// ```
//-----------------------------------------------------------------------------

reducemap(op, foo, n, x) = compute ~ (_,_,_) : (!,!,_)
    with {
        compute(acc, count, val) =
            ba.if(count<n, op(acc,x), x),   // new acc
            ba.if(count<n, count+1, 1),     // new count
            ba.if(count<n, val, foo(acc));  // new val
    };

  
// the sum of the amplitudes of the input signal
sumn(n) = reduce(+,n);

// the maximum amplitude of the input signal
maxn(n) = reduce(max,n);

// the minimum amplitude of the input signal
minn(n) = reduce(min,n);

// the average amplitude of the input signal
mean(n) = reducemap(+, /(n), n);

// RMS
RMS(n) = float : ^(2) : reducemap(+, (/(n):sqrt), n);

