ba = library("basics.lib");
ma = library("maths.lib");
si = library("signals.lib");

// TODO: in Dexed, the parameters are only set during a keyDown event, but we
// update them continuously. This probably leads to some artifacts if the parameters
// are changing.

_ScaleCurve(group, depth, curve) = ba.if(curve < 2, -scale, scale)
with {
  // linear
  scaleLinear = int(group * depth * 329) >> 12;

  // exponential
  raw_exp = exp_scale_data(group);
  scaleExp = int(raw_exp * depth * 329) >> 15;

  scale = ba.if( (curve == 0) | (curve == 3), scaleLinear, scaleExp);

  // TODO: use ba.tabulateNd?
  exp_scale_data = round : rdtable(waveform{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 14, 16, 19, 23, 27, 33, 39, 47, 56, 66,
    80, 94, 110, 126, 142, 158, 174, 190, 206, 222, 238, 250
  });
};

// https://github.com/asb2m10/dexed/blob/e087754595af33a5a487cb08a213cf6a62edd463/Source/msfa/dx7note.cc#L101
ScaleLevel(midinote, break_pt, left_depth, right_depth, left_curve, right_curve) = ba.if(offset >= 0, rightVal, leftVal)
with {
  offset = midinote - break_pt - 17;
  rightVal = _ScaleCurve((offset+1) / 3, right_depth, right_curve);
  leftVal = _ScaleCurve(-1*(offset-1) / 3, left_depth, left_curve);
};

// env.cc lines ~109-111
scaleoutlevel(outlevel) = ba.if(outlevel >= 20, 28 + outlevel, levellut(outlevel))
with {
  // TODO: use ba.tabulateNd?
  levellut = round : rdtable(waveform{
    0, 5, 9, 13, 17, 20, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 42, 43, 45, 46
  });
};

ScaleVelocity(velocity, sensitivity) = scaled_vel
with {
  clamped_vel = max(0, min(127, velocity));
  vel_value = velocity_data(int(clamped_vel) >> 1) - 239;
  scaled_vel = (int(sensitivity * vel_value + 7) >> 3) << 4;

  // TODO: use ba.tabulateNd?
  velocity_data = round : rdtable(waveform{
    0, 70, 86, 97, 106, 114, 121, 126, 132, 138, 142, 148, 152, 156, 160, 163,
    166, 170, 173, 174, 178, 181, 184, 186, 189, 190, 194, 196, 198, 200, 202,
    205, 206, 209, 211, 214, 216, 218, 220, 222, 224, 225, 227, 229, 230, 232,
    233, 235, 237, 238, 240, 241, 242, 243, 244, 246, 246, 248, 249, 250, 251,
    252, 253, 254
  });
};

ScaleRate(midinote, sensitivity) = ba.ifNc(2,
  (sensitivity == 3) & (rem == 3), qratedelta-1,
  (sensitivity == 7) & (rem > 0) & (rem < 4), qratedelta+1,
  qratedelta
)
with {
  x = min(31, max(0, int(midinote / 3) - 7));
  qratedelta = int(sensitivity * x) >> 3;
  rem = x & 7;
};


//--------------------`(dx.)env`-----------------------------------------
//
// Volume Envelope in the DX7, based on Dexed/MSFA code.
// The output is a Q24 number, so you may want to use `q24_to_linear`
// to get a number in [0,1]
// 
// #### Usage
// ```
// env(rates, levels, outlevel, rate_scaling, gate) : q24_to_linear
// ```
//
// Where:
//
// * `rates`: 4 channels of rates between 0-99
// * `levels`: 4 channels of levels between 0-99
// * `outlevel`: Out level in 0-99
// * `rate_scaling`: A value whose range is hard to describe. See the usage with `ScaleRate`
// * `gate`: trigger
//
// #### Test
// ```
// env = library("env.lib");
// env_test = env.env((60,61,62,63), (60,61,62,63), 80, 90, button("gate")) : env.q24_to_linear;
// ```
//
// #### Reference
//
// * <https://github.com/asb2m10/dexed/blob/master/Source/msfa/env.cc>
//-----------------------------------------------------------------------------
declare env author "David Braun";
declare env copyright "Copyright (C) 2025 David Braun";
declare env license "Apache License, Version 2.0";
env(rates, levels, outlevel, rate_scaling, gate) = ((keyDown : keyUp : accurateEnvelope : cond1) ~ si.bus(7)) : _, !,!,!,!,!,!
with {

  // init_sr
  sr_multiplier = 44100.0 / ma.SR;
  
  // TODO: use ba.tabulateNd?
  statics = round : rdtable(waveform{
    1764000, 1764000, 1411200, 1411200, 1190700, 1014300, 992250,
    882000, 705600, 705600, 584325, 507150, 502740, 441000, 418950,
    352800, 308700, 286650, 253575, 220500, 220500, 176400, 145530,
    145530, 125685, 110250, 110250, 88200, 88200, 74970, 61740,
    61740, 55125, 48510, 44100, 37485, 31311, 30870, 27562, 27562,
    22050, 18522, 17640, 15435, 14112, 13230, 11025, 9261, 9261, 7717,
    6615, 6615, 5512, 5512, 4410, 3969, 3969, 3439, 2866, 2690, 2249,
    1984, 1896, 1808, 1411, 1367, 1234, 1146, 926, 837, 837, 705,
    573, 573, 529, 441, 441
    // and so on, I stopped measuring after R=76 (needs to be double-checked anyway)
  });

  // env.cc lines ~51-61
  keyDown(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = unchanged <: si.bus(7), changed : ba.selectbus(7, 2, gate>(gate')) with
  {
    unchanged = level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_;
    changed = advance(0, 0, targetlevel_, rising_, inc_, 1, staticcount_);
  };

  // env.cc lines ~102-107 (assume incoming `d` is false)
  keyUp(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = unchanged <: si.bus(7), changed : ba.selectbus(7, 2, gate<(gate')) with
  {
    unchanged = level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_;
    changed = advance(level_, 3, targetlevel_, rising_, inc_, 0, staticcount_);
  };

  // env.cc lines ~64-72
  // The original Dexed C++ decrements staticcount_ by N (=64) each time the
  // envelope is evaluated because `getsample()` is called only once every
  // 64 audio samples. In this Faust version we evaluate the envelope at the
  // full sample-rate, therefore we subtract 1 per sample instead of N and
  // we reach the “end of static” test when staticcount_ == 1.
  accurateEnvelope(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = path1, path2 : ba.selectbus(7, 2, (staticcount_ != 0) & (staticcount_ <= 1))
  with {
    path1 = level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_ - ba.if(staticcount_ != 0, 1, 0);
    path2 = advance(level_, ix_+1, targetlevel_, rising_, inc_, down_, 0);
    
  };

  // env.cc line 74
  cond1(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = unchanged <: si.bus(7), cond2 : ba.selectbus(7,2, ((ix_ < 3) | ((ix_<4) & ma.not(down_))))
  with {
    // TODO: this would be a good place to set level_ to 0 when under threshold
    unchanged = level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_;
  };

  // env.cc lines ~75-96
  cond2(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = unchanged, path1, path2 : ba.selectbus(7,3, (staticcount_==0)*(1+(rising_==0)))
  with {
    unchanged = level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_;

    // path when rising_ != 0 (lines ~79-88)
    path1 = dont_advance, do_advance : ba.selectbus(7,2, level_a >= targetlevel_)
    with {
      jumptarget = 1716 << 16;
      level_a = max(jumptarget, level_)
        <: _ + (((17 << 24) - int(_)) >> 24) * inc_; // TODO: should probably be more accurate when inc is large
      
      dont_advance = level_a, ix_, targetlevel_, rising_, inc_, down_, staticcount_;
      do_advance = advance(targetlevel_, ix_+1, targetlevel_, rising_, inc_, down_, staticcount_);
    }; 

    // path when rising == 0 (lines ~91-94)
    path2 = dec_level, do_advance : ba.selectbus(7, 2, (level_ - inc_) <= targetlevel_)
    with {
      dec_level = level_ - inc_, ix_, targetlevel_, rising_, inc_, down_, staticcount_;
      do_advance = advance(targetlevel_, ix_ + 1, targetlevel_, rising_, inc_, down_, staticcount_);
    };
  };

  // env.cc lines ~113-151
  advance(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = unchanged <: si.bus(7), cond7 : ba.selectbus(7, 2, ix_ < 4)
  with {
    unchanged = level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_;
  };

  // this is the logic inside env.cc lines ~116-149.
  cond7(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = level_, ix_, newtargetlevel, newrising_, newinc, down_, staticcount_ : advanceAccurateEnvelope
  with {
    newlevel = levels : ba.selectn(4, ix_);
    actuallevel = scaleoutlevel(newlevel) >> 1 : (_ << 6) + outlevel - 4256 : max(16) : int;
    // level here is same as Java impl
    newtargetlevel = actuallevel << 16;
    newrising_ = (newtargetlevel > level_);

    // rate
    qrate = int(int(rates : ba.selectn(4, ix_)) * 41) >> 6 : _+rate_scaling : min(63);

    // env.cc lines ~147-149
    // In the original Dexed C++ implementation `getsample()` is executed once
    // per audio block of 64 samples, therefore `inc_` is multiplied by 64 with
    // the extra `+ LG_N` shift.  Here the envelope is evaluated every audio
    // sample, so we remove that additional factor.
    raw_inc = (4 + (int(qrate) & 3)) << (2 + (int(qrate) >> 2));
    newinc = int(float(raw_inc) * sr_multiplier);
  };

  // env.cc lines ~129-146
  advanceAccurateEnvelope(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = level_, ix_, targetlevel_, rising_, inc_, down_, newstaticcount
  with {
    newlevel = levels : ba.selectn(4, ix_);
    // approximate number of samples at 44.100 kHz to achieve the time
    // empirically gathered using 2 TF1s, could probably use some double-checking
    // and cleanup, but it's pretty close for now.
    staticrate_a = rates : ba.selectn(4, ix_);
    staticrate_b = staticrate_a + rate_scaling; // needs to be checked, as well, but seems correct
    staticrate_c = min(staticrate_b, 99);
    staticcount_a = ba.if(staticrate_c < 77, statics(staticrate_c), 20 * (99 - staticrate_c));
    staticcount_b = ba.if((staticrate_c < 77) & (ix_ == 0) & (newlevel == 0),
      staticcount_a/20, // attack is scaled faster
      staticcount_a);

    // Same 64-bit overflow problem as above – do it in floating-point.
    staticcount_c = int(staticcount_b * sr_multiplier);

    newstaticcount = ba.if((targetlevel_ == level_) | ((ix_ == 0) & (newlevel == 0)), staticcount_c, 0);
  };

  // env.cc lines ~153-169
  // note: only used if `refreshVoices` is true
  // https://github.com/asb2m10/dexed/blob/e087754595af33a5a487cb08a213cf6a62edd463/Source/PluginParam.cpp#L673
  update(level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_) = unchanged, changed : ba.selectbus(7, 2, down_!=0)
  with {
    unchanged = level_, ix_, targetlevel_, rising_, inc_, down_, staticcount_;

    newlevel = levels : ba.selectn(4, 2);
    actuallevel = scaleoutlevel(newlevel) >> 1 : (_ << 6) - 4256 : max(16) : int;
    newtargetlevel = actuallevel << 16;
    changed = advance(level_, 2, newtargetlevel, rising_, inc_, down_, staticcount_);
  };
};

q24_to_linear = pow(2.0, float(_ - (14 << 24)) / float(1<<24));

// --- Tests ---

// Test this with polyphony set to 1.
// process = vgroup("Env", env(rates, levels, outlevel, rate_scaling, gate))
// : q24_to_linear
// with {
//   freq = hslider("freq [hidden:1]",400,50,1000,0.01);
//   gain = hslider("gain [hidden:1]",1,0,1,0.01);
//   gate = button("gate");

//   LEVELS(x) = hgroup("[0] Levels", round(x));
//   RATES(x) = hgroup("[1] Rates", round(x));
//   OTHER(x) = hgroup("[2] Other", round(x));

//   egL1 = LEVELS(hslider("[0] L1 [style:knob]",99,0,99,1));
//   egL2 = LEVELS(hslider("[1] L2 [style:knob]",99,0,99,1));
//   egL3 = LEVELS(hslider("[2] L3 [style:knob]",99,0,99,1));
//   egL4 = LEVELS(hslider("[3] L4 [style:knob]",0,0,99,1));

//   egR1 = RATES(hslider("[0] R1 [style:knob]",99,0,99,1));
//   egR2 = RATES(hslider("[1] R2 [style:knob]",99,0,99,1));
//   egR3 = RATES(hslider("[2] R3 [style:knob]",99,0,99,1));
//   egR4 = RATES(hslider("[3] R4 [style:knob]",99,0,99,1));

//   keyVelSens = OTHER(hslider("[3] Key Vel [style:knob]",0,0,7,1));

//   midinote = freq : ba.hz2midikey : round;

//   BREAKPOINT(x) = hgroup("[2] Break Point", x);

//   breakpoint       = BREAKPOINT(hslider("[0] Break Point [style:knob]", 0, 0, 99, 1));
//   breakpointLDepth = BREAKPOINT(hslider("[1] L Depth [style:knob]", 0, 0, 99, 1));
//   breakpointRDepth = BREAKPOINT(hslider("[2] R Depth [style:knob]", 0, 0, 99, 1));
//   breakpointLCurve = BREAKPOINT(nentry("[3] L Curve [style:menu{'-LIN':0;'-EXP':1;'+EXP':2;'+LIN':3}]",0,0,3,1));
//   breakpointRCurve = BREAKPOINT(nentry("[4] R Curve [style:menu{'-LIN':0;'-EXP':1;'+EXP':2;'+LIN':3}]",0,0,3,1));

//   level_scaling = ScaleLevel(midinote, breakpoint, breakpointLDepth, breakpointRDepth, breakpointLCurve, breakpointRCurve);

//   rates = egR1, egR2, egR3, egR4;
//   levels = egL1, egL2, egL3, egL4;
//   outlevel = OTHER(hslider("[2] Level [style:knob]",90,0,99,1)) <: scaleoutlevel(_) + level_scaling
//       : min(127)
//       : int(_) << 5
//       : _ + ScaleVelocity(gain*127, keyVelSens)
//       : max(0)
//   ;
//   rate_scaling = OTHER(hslider("[1] Rate Scale [style:knob]",1,0,7,1)) : ScaleRate(midinote);
// };
