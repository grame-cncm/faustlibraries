//#################################### dx7.lib #################################
// Yamaha DX7 emulation library. Its official prefix is `dx`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/dx7/dx7.lib>
//##############################################################################
// Yamaha DX7 emulation library. The various functions available in this library
// are used by the libraries generated from `.syx` DX7 preset files. This
// toolkit was greatly inspired by Dexed:
// <https://github.com/asb2m10/dexed>.
//
// This library and its related tools are under development. Use it at your
// own risk!
//##############################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2025 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");

declare version "2.0.0";

import("operator.lib");

// TODO:
// * Double-check feedback gain. There are artifacts that sound like aliasing for high feedback values.
// * It may be wise to make the operator produce Q24 values instead of how we currently make [-1 to 1].
//   Then follow EngineMkI.cpp more verbatim.
// * Try to eliminate usage of int and round, make everything continuous
// * Consider using ba.tabulateNd in some places.


FEEDBACK_BITDEPTH = 8;


//----------------------`(dx.)fdbkscalef`----------------------------------
// DX7 feedback scaling conversion function.
// Index 0 is special: it disables the feedback path entirely.
//
// #### Usage:
//
// ```
// fdbkscalef(fb_shift) : _
// ```
//
// Where:
//
// * `fb_shift`: DX7 feedback value
//
// #### Reference
// <https://github.com/asb2m10/dexed/blob/master/Source/EngineMkI.cpp>
//-----------------------------------------------------------------------------
fdbkscalef(feedback) = ba.if(feedback==0, 0, pow(2, 1-fb_shift))
with {
  fb_shift = FEEDBACK_BITDEPTH - feedback;
};
declare fdbkscalef author "David Braun";
declare fdbkscalef copyright "Copyright (C) 2025 David Braun";
declare fdbkscalef license "Apache License, Version 2.0";


//----------------------`(dx.)fdbkscalef2`---------------------------------
// DX7 feedback scaling conversion function for algos 4, 6, 32.
// Index 0 is special: it disables the feedback path entirely.
//
// #### Usage:
//
// ```
// fdbkscalef2(fb_shift) : _
// ```
//
// Where:
//
// * `fb_shift`: DX7 feedback value
//
// #### Reference
// <https://github.com/asb2m10/dexed/blob/master/Source/EngineMkI.cpp>
//-----------------------------------------------------------------------------
fdbkscalef2(feedback) = ba.if(feedback==0, 0, pow(2, 1-fb_shift))
with {
  fb_shift = FEEDBACK_BITDEPTH - feedback : _+2 : min(16);
};
declare fdbkscalef2 author "David Braun";
declare fdbkscalef2 copyright "Copyright (C) 2025 David Braun";
declare fdbkscalef2 license "Apache License, Version 2.0";


//------------------------------`(dx.)algorithms`---------------------------
// Generic DX7 function where all parameters are controllable using UI elements.
// This function is MIDI-compatible.
//
// #### Usage
//
// ```
// algorithms : _
// ```
//-----------------------------------------------------------------------------
algorithms = par(i,32,algorithm(i+1) : control(algo-1 == i)) :> _
with {
  algo = nentry("h:DX7/v:Global/h:Main/Algorithm", 1, 1, 32, 1);
};
declare algorithms author "David Braun";
declare algorithms copyright "Copyright (C) 2025 David Braun";
declare algorithms license "Apache License, Version 2.0";


//------------------------------`(dx.)algorithm`---------------------------
// DX7 function for a specific algorithm at compile-time. This function
// comes with a GUI and is MIDI-compatible.
//
// #### Usage
//
// ```
// algorithm(algo) : _
// ```
//
// Where:
//
// * `algo`: algorithm identifier (1-32)
//
//-----------------------------------------------------------------------------
declare algorithm author "David Braun";
declare algorithm copyright "Copyright (C) 2025 David Braun";
declare algorithm license "Apache License, Version 2.0";
algorithm(algo) = hgroup("DX7", dx7_algo(algo))
with {

  freq = hslider("freq [hidden:1]",400,50,1000,0.01);
  gain = hslider("gain [hidden:1]",0.8,0,1,0.01);
  gate = button("gate [hidden:1]");

  GLOBAL(x) = vgroup("Global", round(x));
  MAIN(x) = GLOBAL(hgroup("[0] Main", x));
  PEGL(x) = GLOBAL(hgroup("[1] Pitch EG Levels", x));
  PEGR(x) = GLOBAL(hgroup("[2] Pitch EG Rates", x));
  LFO(x) = GLOBAL(hgroup("[3] LFO", x));

  fbKnob = MAIN(hslider("[0] Feedback [style:knob]",0,0,7,1));
  feedbackAmp = fbKnob : fdbkscalef;
  feedbackAmp2 = fbKnob : fdbkscalef2; // for algos 4, 6, 32
  transpose = MAIN(hslider("[1] Transpose [style:knob]",0,-24,24,1));
  oscKeySync = MAIN(hslider("[2] Osc Key Sync [style:knob]",1,0,1,1));

  pegL1 = PEGL(hslider("[0] L1 [style:knob]",50,0,99,1));
  pegL2 = PEGL(hslider("[1] L2 [style:knob]",50,0,99,1));
  pegL3 = PEGL(hslider("[2] L3 [style:knob]",50,0,99,1));
  pegL4 = PEGL(hslider("[3] L4 [style:knob]",50,0,99,1));

  pegR1 = PEGR(hslider("[0] R1 [style:knob]",99,0,99,1));
  pegR2 = PEGR(hslider("[1] R2 [style:knob]",99,0,99,1));
  pegR3 = PEGR(hslider("[2] R3 [style:knob]",99,0,99,1));
  pegR4 = PEGR(hslider("[3] R4 [style:knob]",99,0,99,1));

  lfoWave = LFO(nentry("[0] Wave [style:menu{'Triangle':0;'Saw Down':1;'Saw Up':2;'Square':3;'Sine':4;'Sample & Hold':5}]",0,0,5,1));
  lfoSpeed = LFO(hslider("[1] Speed [style:knob]",35,0,99,1));
  lfoDelay = LFO(hslider("[2] Delay [style:knob]",0,0,99,1));
  lfoPMD = LFO(hslider("[3] PMD [style:knob]",0,0,99,1));
  lfoAMD = LFO(hslider("[4] AMD [style:knob]",0,0,99,1));
  lfoSync = LFO(hslider("[5] Sync [style:knob]",1,0,1,1));
  lfoPitchModSens = LFO(hslider("[6] P Mod Sens [style:knob]",3,0,7,1));

  // concise way of making the same UI element for all 6 operators.
  oppar(param, n) = ba.take(n+1, par(i, 6, func(i))) : round
  with {
    func(i) = vgroup("[%i] Operator %j", param)
    with {
      j = i+1;
    };
  };

  TONE(x) = hgroup("[0] Tone", x);

  AEG(x) = vgroup("[1] Amp Env Generator", x);
  LEVELS(x) = AEG(hgroup("[0] Levels", x));
  RATES(x) = AEG(hgroup("[1] Rates", x));

  LEVEL(x) = hgroup("[2] Level", x);
  BREAKPOINT(x) = hgroup("[3] Breakpoint", x);

  // Each of these is a `getSomeParameterForOperator(i)` for i [0-5]
  egL1           = oppar(LEVELS(hslider("[0] L1 [style:knob]",99,0,99,1)));
  egL2           = oppar(LEVELS(hslider("[1] L2 [style:knob]",99,0,99,1)));
  egL3           = oppar(LEVELS(hslider("[2] L3 [style:knob]",99,0,99,1)));
  egL4           = oppar(LEVELS(hslider("[3] L4 [style:knob]",0,0,99,1)));
  egR1           = oppar(RATES(hslider("[0] R1 [style:knob]",99,0,99,1)));
  egR2           = oppar(RATES(hslider("[1] R2 [style:knob]",99,0,99,1)));
  egR3           = oppar(RATES(hslider("[2] R3 [style:knob]",99,0,99,1)));
  egR4           = oppar(RATES(hslider("[3] R4 [style:knob]",99,0,99,1)));
  outLevel(k)    = oppar(LEVEL(hslider("[0] Level [style:knob]",select2(k==0, 0, 99),0,99,1)));
  keyVelSens     = oppar(LEVEL(hslider("[1] Key Vel [style:knob]",0,0,7,1)));
  ampModSens     = oppar(LEVEL(hslider("[2] A Mod Sens [style:knob]",0,0,3,1)));
  rateScale      = oppar(LEVEL(hslider("[3] Rate Scaling [style:knob]",0,0,7,1)));

  detune         = oppar(TONE(hslider("[0] Tune [style:knob]",0,-7,7,1)));
  freqCoarse     = oppar(TONE(hslider("[1] Coarse [style:knob]",1,0.0,31,1)));
  freqFine       = oppar(TONE(hslider("[2] Fine [style:knob]",0,0.0,99,1)));
  freqMode       = oppar(TONE(checkbox("[3] Freq Mode [style:knob]")));

  breakpoint       = oppar(BREAKPOINT(hslider("[0] Breakpoint [style:knob]", 0, 0, 99, 1)));
  breakpointLDepth = oppar(BREAKPOINT(hslider("[1] L Depth [style:knob]", 0, 0, 99, 1)));
  breakpointRDepth = oppar(BREAKPOINT(hslider("[2] R Depth [style:knob]", 0, 0, 99, 1)));
  breakpointLCurve = oppar(BREAKPOINT(nentry("[3] L Curve [style:menu{'-LIN':0;'-EXP':1;'+EXP':2;'+LIN':3}]",0,0,3,1)));
  breakpointRCurve = oppar(BREAKPOINT(nentry("[4] R Curve [style:menu{'-LIN':0;'-EXP':1;'+EXP':2;'+LIN':3}]",0,0,3,1)));

  op(i, phase_mod) = operator(
    freqMode(i),
    freqCoarse(i),
    freqFine(i),
    detune(i),
    outLevel(i, i),
    egR1(i),
    egR2(i),
    egR3(i),
    egR4(i),
    egL1(i),
    egL2(i),
    egL3(i),
    egL4(i),
    keyVelSens(i),
    ampModSens(i),
    rateScale(i),
    breakpoint(i),
    breakpointLDepth(i),
    breakpointRDepth(i),
    breakpointLCurve(i),
    breakpointRCurve(i),
    lfoWave,
    lfoSpeed,
    lfoDelay,
    lfoPMD,
    lfoAMD,
    lfoSync,
    lfoPitchModSens,
    oscKeySync,
    pegR1,
    pegR2,
    pegR3,
    pegR4,
    pegL1,
    pegL2,
    pegL3,
    pegL4,
    transpose,
    phase_mod,
    freq,
    gain,
    gate
  );

  dx7_algo(1) = (op2 : op1),(op6~*(feedbackAmp) : op5 : op4 : op3) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(2) = (op2~*(feedbackAmp) : op1),(op6 : op5 : op4 : op3) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(3) = (op3 : op2 : op1),(op6~*(feedbackAmp) : op5 : op4) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2, 0);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(4) = (op3 : op2 : op1),(op6 : op5 : op4)~*(feedbackAmp2) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2, 0);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(5) = (op2 : op1),(op4 : op3),(op6~*(feedbackAmp) : op5) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(6) = (op2 : op1),(op4 : op3),(op6 : op5)~*(feedbackAmp2) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(7) = (op2 : op1),(op4,(op6~*(feedbackAmp) : op5) :> op3) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(8) = (op2 : op1),(op4~*(feedbackAmp),(op6 : op5) :> op3) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(9) = (op2~*(feedbackAmp) : op1),(op4,(op6 : op5) :> op3) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(10) = (op5,op6 :> op4),(op3~*(feedbackAmp) : op2 : op1) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4, 0);
    op6 = op(5, 0);
  };

  dx7_algo(11) = (op5,op6~*(feedbackAmp) :> op4),(op3 : op2 : op1) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2, 0);
    op4 = op(3);
    op5 = op(4, 0);
    op6 = op(5);
  };

  dx7_algo(12) = (op4,op5,op6 :> op3),(op2~*(feedbackAmp) : op1) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4, 0);
    op6 = op(5, 0);
  };

  dx7_algo(13) = (op4,op5,op6~*(feedbackAmp) :> op3),(op2 : op1) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4, 0);
    op6 = op(5);
  };

  dx7_algo(14) = (op2 : op1),(op5,op6~*(feedbackAmp) :> op4 : op3) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4, 0);
    op6 = op(5);
  };

  dx7_algo(15) = (op2~*(feedbackAmp) : op1),(op5,op6 :> op4 : op3) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4, 0);
    op6 = op(5, 0);
  };

  dx7_algo(16) = op2,(op4 : op3),(op6~*(feedbackAmp) : op5) :> op1 : _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(17) = op2~*(feedbackAmp),(op4 : op3),(op6 : op5) :> op1 : _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(18) = op2,op3~*(feedbackAmp),(op6 : op5 : op4) :> op1 : _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(19) = (op3 : op2 : op1),(op6~*(feedbackAmp) <: op4,op5) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2, 0);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(20) = (op3~*(feedbackAmp) <: op1,op2),(op5,op6 :> op4) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4, 0);
    op6 = op(5, 0);
  };

  dx7_algo(21) = (op3~*(feedbackAmp) <: op1,op2),(op6 <: op4,op5) :> _
  with {
    op1 = op(0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(22) = (op2 : op1),(op6~*(feedbackAmp) <: op3,op4,op5) :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(23) = op1,(op3 : op2),(op6~*(feedbackAmp) <: op4,op5) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1);
    op3 = op(2, 0);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(24) = op1,op2,(op6~*(feedbackAmp) <: op3,op4,op5) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(25) = op1,op2,op3,(op6~*(feedbackAmp) <: op4,op5) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1, 0);
    op3 = op(2, 0);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(26) = op1,(op3 : op2),(op5,op6~*(feedbackAmp) :> op4) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1);
    op3 = op(2, 0);
    op4 = op(3);
    op5 = op(4, 0);
    op6 = op(5);
  };

  dx7_algo(27) = op1,(op3~*(feedbackAmp) : op2),(op5,op6 :> op4) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4, 0);
    op6 = op(5, 0);
  };

  dx7_algo(28) = (op2 : op1),(op5~*(feedbackAmp) : op4 : op3),op6 :> _
  with {
    op1 = op(0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(29) = op1,op2,(op4 : op3),(op6~*(feedbackAmp) : op5) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(30) = op1,op2,(op5~*(feedbackAmp) : op4 : op3),op6 :> _
  with {
    op1 = op(0, 0);
    op2 = op(1, 0);
    op3 = op(2);
    op4 = op(3);
    op5 = op(4);
    op6 = op(5, 0);
  };

  dx7_algo(31) = op1,op2,op3,op4,(op6~*(feedbackAmp) : op5) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1, 0);
    op3 = op(2, 0);
    op4 = op(3, 0);
    op5 = op(4);
    op6 = op(5);
  };

  dx7_algo(32) = op1,op2,op3,op4,op5,(op6~*(feedbackAmp2)) :> _
  with {
    op1 = op(0, 0);
    op2 = op(1, 0);
    op3 = op(2, 0);
    op4 = op(3, 0);
    op5 = op(4, 0);
    op6 = op(5);
  };

};

// --- Tests ---

// process = algorithm(1) <: _,_;
// process = algorithm(2) <: _,_;
// process = algorithm(3) <: _,_;
// process = algorithm(4) <: _,_;
// process = algorithm(5) <: _,_;
// process = algorithm(6) <: _,_;
// process = algorithm(7) <: _,_;
// process = algorithm(8) <: _,_;
// process = algorithm(9) <: _,_;
// process = algorithm(10) <: _,_;
// process = algorithm(11) <: _,_;
// process = algorithm(12) <: _,_;
// process = algorithm(13) <: _,_;
// process = algorithm(14) <: _,_;
// process = algorithm(15) <: _,_;
// process = algorithm(16) <: _,_;
// process = algorithm(17) <: _,_;
// process = algorithm(18) <: _,_;
// process = algorithm(19) <: _,_;
// process = algorithm(20) <: _,_;
// process = algorithm(21) <: _,_;
// process = algorithm(22) <: _,_;
// process = algorithm(23) <: _,_;
// process = algorithm(24) <: _,_;
// process = algorithm(25) <: _,_;
// process = algorithm(26) <: _,_;
// process = algorithm(27) <: _,_;
// process = algorithm(28) <: _,_;
// process = algorithm(29) <: _,_;
// process = algorithm(30) <: _,_;
// process = algorithm(31) <: _,_;
// process = algorithm(32) <: _,_;
