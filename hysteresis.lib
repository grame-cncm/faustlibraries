//################################ hysteresis.lib ##########################################
// Hysteresis library. Its official prefix is `hy`.
//
// This library provides physics-based magnetic hysteresis models for audio processing.
// Suitable for transformer saturation, tape emulation, and magnetic effects.
//
// Currently implemented models:
// * Jiles-Atherton (ja_*) - Physics-based ferromagnetic hysteresis
//
// The Hysteresis library is organized into 3 sections:
//
// * [Jiles-Atherton Core](#jiles-atherton-core)
// * [Jiles-Atherton Processors](#jiles-atherton-processors)
// * [Jiles-Atherton UI Wrappers](#jiles-atherton-ui-wrappers)
//
// #### Musical Character
//
// The `c` (reversibility) and input calibration work together:
//
// | Calibration | c    | Character                      |
// |-------------|------|--------------------------------|
// | -50 dB      | 0.25 | Forward, open, dynamic         |
// | 0 dB        | 0.9  | Compressed, set back, controlled |
//
// Blend between these extremes for different textures.
//
// #### References
//
// * <https://en.wikipedia.org/wiki/Jiles-Atherton_model>
// * <https://github.com/grame-cncm/faustlibraries>
//############################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2025 Thomas Mandolini
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");
si = library("signals.lib");
ma = library("maths.lib");
fi = library("filters.lib");

declare name "Faust Hysteresis Library";
declare author "Thomas Mandolini";
declare version "1.0.1";

//========================== Jiles-Atherton Core =====================================
// The core hysteresis function implementing the Jiles-Atherton model with
// 4x cascaded substeps and cubic Hermite interpolation for smooth transients.
//====================================================================================

//--------------------`(hy.)ja_hysteresis`-------------------
// Jiles-Atherton hysteresis core with 4x substep interpolation.
// Implements magnetic hysteresis with smooth transient response using
// cubic Hermite interpolation between samples.
//
// #### Usage
//
// ```
// _ : ja_hysteresis(Ms, a, alpha, k, c) : _
// ```
//
// Where:
//
// * `Ms`: saturation magnetization, controls maximum output level (100-1000, default 380)
// * `a`: anhysteretic curve shape parameter (100-2000, default 720)
// * `alpha`: mean-field coupling coefficient (0.001-0.1, default 0.015)
// * `k`: coercivity, controls hysteresis loop width (50-1000, default 380)
// * `c`: reversibility factor, ratio of reversible to irreversible magnetization (0-1, default 0.25)
//
// #### Test
// ```
// hy = library("hysteresis.lib");
// os = library("oscillators.lib");
// ja_hysteresis_test = os.osc(100) * 0.5 : hy.ja_hysteresis(380, 720, 0.015, 380, 0.25);
// ```
//
// #### References
//
// * <https://en.wikipedia.org/wiki/Jiles-Atherton_model>
// * <https://www.sciencedirect.com/science/article/abs/pii/S0304885321006466>
//------------------------------------------------------------
declare ja_hysteresis author "Thomas Mandolini";
declare ja_hysteresis license "LGPLv2.1";

ja_hysteresis(Ms, a, alpha, k, c) = core
with {
    // Normalized parameters for numerical stability
    Ms_safe = max(Ms, 1e-6);
    a_norm = a / Ms_safe;
    k_norm = k / Ms_safe;
    inv_a_norm = 1.0 / max(a_norm, 1e-9);
    sigma = 1e-3;
    diff_scale = 3.0;

    // Single J-A substep: M_prev, H_prev, H_target -> M_new
    substep(M_prev, H_prev, H_target) = M_new
    with {
        dH = H_target - H_prev;
        He = H_target + alpha * M_prev;

        // Anhysteretic magnetization (Langevin function approximated by tanh)
        x_man = He * inv_a_norm;
        Man_e = ma.tanh(x_man);
        Man_e2 = Man_e * Man_e;
        dMan_dH = (1.0 - Man_e2) * inv_a_norm;

        // Difference from anhysteretic with soft clamping
        diff = Man_e - M_prev;
        diff_clamped = diff / (1.0 + abs(diff) * diff_scale);

        // Direction-dependent pinning
        dir = ba.if(dH >= 0.0, 1.0, -1.0);
        pin = dir * k_norm - alpha * diff_clamped;
        inv_pin = 1.0 / (pin + sigma);

        // Magnetization derivative
        denom = 1.0 - c * alpha * dMan_dH;
        inv_denom = 1.0 / (denom + 1e-9);
        dMdH = (c * dMan_dH + diff_clamped * inv_pin) * inv_denom;
        dM_step = dMdH * dH;

        // Clamped output
        M_unclamped = M_prev + dM_step;
        M_new = max(-1.0, min(1.0, M_unclamped));
    };

    // 4x cascaded substeps with cubic Hermite interpolation
    // Uses H history for smooth tangent-matched curve between samples
    core(H_in) = (loop ~ (_, _, _)) : (_, !, !)
    with {
        loop(M_prev, H_prev, H_prev_prev) = M4, H_in, H_prev
        with {
            // Tangent estimation (Catmull-Rom style)
            dH_prev = H_prev - H_prev_prev;
            dH_in = H_in - H_prev;

            // Hermite cubic interpolation at t = 0.25, 0.5, 0.75, 1.0
            H1 = 0.84375*H_prev + 0.140625*dH_prev + 0.15625*H_in - 0.046875*dH_in;
            H2 = 0.5*H_prev + 0.125*dH_prev + 0.5*H_in - 0.125*dH_in;
            H3 = 0.15625*H_prev + 0.046875*dH_prev + 0.84375*H_in - 0.140625*dH_in;
            H4 = H_in;

            // Cascaded substeps
            M1 = substep(M_prev, H_prev, H1);
            M2 = substep(M1, H1, H2);
            M3 = substep(M2, H2, H3);
            M4 = substep(M3, H3, H4);
        };
    };
};


//====================== Jiles-Atherton Processors ===================================
// Ready-to-use processors with gain staging and DC blocking.
//====================================================================================

//--------------------`(hy.)ja_processor`-------------------
// Complete mono Jiles-Atherton hysteresis processor with drive control,
// automatic gain compensation, and DC blocking.
//
// #### Usage
//
// ```
// _ : ja_processor(Ms, a, alpha, k, c, drive, trim) : _
// ```
//
// Where:
//
// * `Ms`: saturation magnetization (100-1000)
// * `a`: anhysteretic curve shape (100-2000)
// * `alpha`: mean-field coupling (0.001-0.1)
// * `k`: coercivity/loop width (50-1000)
// * `c`: reversibility factor (0-1)
// * `drive`: input drive in linear gain (use ba.db2linear for dB)
// * `trim`: output trim in linear gain (use ba.db2linear for dB)
//
// #### Test
// ```
// hy = library("hysteresis.lib");
// ba = library("basics.lib");
// os = library("oscillators.lib");
// ja_processor_test = os.osc(100) : hy.ja_processor(380, 720, 0.015, 380, 0.25, ba.db2linear(10), 1);
// ```
//------------------------------------------------------------
declare ja_processor author "Thomas Mandolini";
declare ja_processor license "LGPLv2.1";

ja_processor(Ms, a, alpha, k, c, drive, trim) = chain
with {
    // Internal calibration for J-A model
    ja_calibration = ba.db2linear(-50);

    // Small-signal normalization: J-A gain ~ c * Ms / a
    ja_norm = a / max(0.01, c * Ms);

    // Drive compensation
    drive_comp = 1.0 / max(0.001, drive);

    // DC Blocker (2nd order SVF TPT highpass at 7Hz, Q=0.7071)
    dc_blocker = fi.SVFTPT.HP2(7.0, 0.7071);

    // Signal chain
    chain = _ * drive * ja_calibration
          : ja_hysteresis(Ms, a, alpha, k, c)
          : _ * ja_norm
          : dc_blocker
          : _ * trim * drive_comp / ja_calibration;
};


//--------------------`(hy.)ja_processor_stereo`-------------------
// Stereo Jiles-Atherton hysteresis processor applying identical processing
// to both channels.
//
// #### Usage
//
// ```
// _,_ : ja_processor_stereo(Ms, a, alpha, k, c, drive, trim) : _,_
// ```
//
// Where:
//
// * `Ms`: saturation magnetization (100-1000)
// * `a`: anhysteretic curve shape (100-2000)
// * `alpha`: mean-field coupling (0.001-0.1)
// * `k`: coercivity/loop width (50-1000)
// * `c`: reversibility factor (0-1)
// * `drive`: input drive in linear gain
// * `trim`: output trim in linear gain
//
// #### Test
// ```
// hy = library("hysteresis.lib");
// ba = library("basics.lib");
// os = library("oscillators.lib");
// ja_processor_stereo_test = os.osc(100), os.osc(150) : hy.ja_processor_stereo(380, 720, 0.015, 380, 0.25, ba.db2linear(10), 1);
// ```
//------------------------------------------------------------
declare ja_processor_stereo author "Thomas Mandolini";
declare ja_processor_stereo license "LGPLv2.1";

ja_processor_stereo(Ms, a, alpha, k, c, drive, trim) =
    par(i, 2, ja_processor(Ms, a, alpha, k, c, drive, trim));


//====================== Jiles-Atherton UI Wrappers ==================================
// Ready-to-use processors with built-in user interface controls.
//====================================================================================

//--------------------`(hy.)ja_processor_ui`-------------------
// Mono Jiles-Atherton hysteresis processor with full UI controls for all parameters.
// Includes smoothed controls and sensible defaults.
//
// #### Usage
//
// ```
// _ : ja_processor_ui : _
// ```
//
// #### Test
// ```
// hy = library("hysteresis.lib");
// os = library("oscillators.lib");
// ja_processor_ui_test = os.osc(100) : hy.ja_processor_ui;
// ```
//------------------------------------------------------------
declare ja_processor_ui author "Thomas Mandolini";
declare ja_processor_ui license "LGPLv2.1";

ja_processor_ui = ja_processor(Ms_ui, a_ui, alpha_ui, k_ui, c_ui, drive_ui, trim_ui)
with {
    // UI groups
    ja_group(x) = hgroup("[0]J-A Hysteresis", x);
    core_group(x) = ja_group(vgroup("[0]Core", x));
    drive_group(x) = ja_group(vgroup("[1]Drive", x));

    // Core material parameters (no smoothing on J-A params - matches original)
    Ms_ui = core_group(hslider("[0]Saturation Ms", 380, 100, 1000, 1)) : si.smoo;
    a_ui = core_group(hslider("[1]Anhysteretic a", 720, 100, 2000, 1));
    k_ui = core_group(hslider("[2]Coercivity k", 380, 50, 1000, 1));
    alpha_ui = core_group(hslider("[3]Alpha coupling", 0.015, 0.001, 0.1, 0.001));
    c_ui = core_group(hslider("[4]Reversibility c", 0.25, 0.0, 1.0, 0.01));

    // Drive controls (only drive has smoothing - matches original)
    drive_ui = drive_group(hslider("[0]Drive [unit:dB]", 0, -50, 50, 0.1)) : ba.db2linear : si.smoo;
    trim_ui = drive_group(hslider("[1]Trim [unit:dB]", 0, -20, 20, 0.1)) : ba.db2linear;
};


//--------------------`(hy.)ja_processor_stereo_ui`-------------------
// Stereo Jiles-Atherton hysteresis processor with full UI controls.
// Applies identical processing to both channels with shared parameters.
//
// #### Usage
//
// ```
// _,_ : ja_processor_stereo_ui : _,_
// ```
//
// #### Test
// ```
// hy = library("hysteresis.lib");
// os = library("oscillators.lib");
// ja_processor_stereo_ui_test = os.osc(100), os.osc(150) : hy.ja_processor_stereo_ui;
// ```
//------------------------------------------------------------
declare ja_processor_stereo_ui author "Thomas Mandolini";
declare ja_processor_stereo_ui license "LGPLv2.1";

ja_processor_stereo_ui = ja_processor_stereo(Ms_ui, a_ui, alpha_ui, k_ui, c_ui, drive_ui, trim_ui)
with {
    // UI groups
    ja_group(x) = hgroup("[0]J-A Hysteresis", x);
    core_group(x) = ja_group(vgroup("[0]Core", x));
    drive_group(x) = ja_group(vgroup("[1]Drive", x));

    // Core material parameters (no smoothing on J-A params - matches original)
    Ms_ui = core_group(hslider("[0]Saturation Ms", 380, 100, 1000, 1)) : si.smoo;
    a_ui = core_group(hslider("[1]Anhysteretic a", 720, 100, 2000, 1));
    k_ui = core_group(hslider("[2]Coercivity k", 380, 50, 1000, 1));
    alpha_ui = core_group(hslider("[3]Alpha coupling", 0.015, 0.001, 0.1, 0.001));
    c_ui = core_group(hslider("[4]Reversibility c", 0.25, 0.0, 1.0, 0.01));

    // Drive controls (only drive has smoothing - matches original)
    drive_ui = drive_group(hslider("[0]Drive [unit:dB]", 0, -50, 50, 0.1)) : ba.db2linear : si.smoo;
    trim_ui = drive_group(hslider("[1]Trim [unit:dB]", 0, -20, 20, 0.1)) : ba.db2linear;
};
